///////////////////////////////////////////////////////////////////////////////
///
/// @file EspDcHallMotorDriver.cpp
///
/// @brief main application entry point of EspDcHallMotorDriver.
///
/// @author Ultratronik GmbH
///         Dornierstr. 9
///         D-82205 Gilching
///         Germany
///         http://www.ultratronik.de
///
/// @author written by Florian Sonntag, Forschung & Entwicklung, gesser@ultratronik.de
///
/// @date 30.10.2021
///
/// @copyright Copyright 2021 by Hemro International AG
///            Hemro International AG
///            Länggenstrasse 34
///            CH 8184 Bachenbülach
///            Switzerland
///            Homepage: www.hemrogroup.com
///
///////////////////////////////////////////////////////////////////////////////

#include "EspDcHallMotorDriver.h"

#include <QDebug>
#include <QtGlobal>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

EspDcHallMotorDriver::EspDcHallMotorDriver( const EkxProtocol::DriverId u8DriverId,
                                            const QString &             strName )
    : EspDeviceDriver( u8DriverId )
    , m_strName( strName )
{
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

EspDcHallMotorDriver::~EspDcHallMotorDriver()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::testMotor()
{
    send( new EkxProtocol::Payload::DcHallTestMotor() );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::startMotor()
{
    startMotor( m_nPwmDuty10th, m_nPwmFrequency );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::startMotor( const int nPwmDuty10th,
                                       const int nPwmFrequency )
{
    qInfo() << "startMotor " << m_strName << " / PwmDuty10th " << nPwmDuty10th << " / PwmFrequency " << nPwmFrequency;

    setPwmDuty10th( nPwmDuty10th );
    setPwmFrequency( nPwmFrequency );

    EkxProtocol::Payload::DcHallStartMotor * pPayload = new EkxProtocol::Payload::DcHallStartMotor();
    pPayload->pwmDuty10th().setValue( nPwmDuty10th );
    pPayload->pwmFrequency().setValue( nPwmFrequency );

    send( pPayload );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::startMotorSteps()
{
    startMotorSteps( m_nSteps, m_nPwmDuty10th, m_nPwmFrequency );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::startMotorSteps( const int nSteps,
                                            const int nPwmDuty10th,
                                            const int nPwmFrequency )
{
    qInfo() << "startMotor " << m_strName << " / Steps " << nSteps << " / PwmDuty10th " << nPwmDuty10th << " / PwmFrequency " << nPwmFrequency;

    setSteps( nSteps );
    setPwmDuty10th( nPwmDuty10th );
    setPwmFrequency( nPwmFrequency );

    EkxProtocol::Payload::DcHallStartMotorSteps * pPayload = new EkxProtocol::Payload::DcHallStartMotorSteps();
    pPayload->steps().setValue( nSteps );
    pPayload->pwmDuty10th().setValue( nPwmDuty10th );
    pPayload->pwmFrequency().setValue( nPwmFrequency );

    send( pPayload );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::stopMotor()
{
    qInfo() << "stopMotor " << m_strName;

    send( new EkxProtocol::Payload::DcHallStopMotor() );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

bool EspDcHallMotorDriver::isMotorTestOk() const
{
    return m_bMotorTestOk;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

bool EspDcHallMotorDriver::isRunning() const
{
    return m_bRunning;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

bool EspDcHallMotorDriver::isFaultPinActive() const
{
    return m_bFaultPinActive;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int EspDcHallMotorDriver::runTimeMs() const
{
    return m_nRunTimeMs;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

bool EspDcHallMotorDriver::isValid() const
{
    return m_bValid;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspDcHallMotorDriver::stepCounter() const
{
    return m_u32StepCounter;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspDcHallMotorDriver::overshootSteps() const
{
    return m_u32OvershootSteps;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setSteps( const int nSteps )
{
    if ( m_nSteps != nSteps )
    {
        m_nSteps = nSteps;
        emit stepsChanged( m_nSteps );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int EspDcHallMotorDriver::steps() const
{
    return m_nSteps;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setPwmDuty10th( const int nPwmDuty10th )
{
    if ( m_nPwmDuty10th != nPwmDuty10th )
    {
        m_nPwmDuty10th = nPwmDuty10th;
        emit pwmDuty10thChanged( m_nPwmDuty10th );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int EspDcHallMotorDriver::pwmDuty10th() const
{
    return m_nPwmDuty10th;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setPwmFrequency( const int nPwmFrequency )
{
    if ( m_nPwmFrequency != nPwmFrequency )
    {
        m_nPwmFrequency = nPwmFrequency;
        emit pwmFrequencyChanged( m_nPwmFrequency );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int EspDcHallMotorDriver::pwmFrequency() const
{
    return m_nPwmFrequency;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::processMessageFrame( const EkxProtocol::MessageFrame & frame )
{
    const EkxProtocol::Payload::DcHallStatus * pPayload = dynamic_cast<const EkxProtocol::Payload::DcHallStatus *>( frame.payloadRef().value() );

    if ( pPayload )
    {
        setValid( pPayload->valid().value() );
        setFaultPinActive( pPayload->faultPinActive().value() );
        setRunning( pPayload->motorRunning().value() );
        setMotorTestOk( pPayload->motorTestOk().value() );
        setRunTimeMs( pPayload->motorRunTime().value() );
        setStepCounter( pPayload->stepCounter().value() );

        if ( isRunning() )
        {
            setOvershootSteps( 0 );
        }
        else
        {
            setOvershootSteps( qMax( 0, static_cast<int>( stepCounter() ) - steps() ) );
        }

        emit statusChanged();

        replyAck( frame.driverId().value(),
                  frame.msgCounter().value(),
                  frame.repeatCounter().value() );
    }
    else
    {
        replyNack( frame.driverId().value(),
                   frame.msgCounter().value(),
                   frame.repeatCounter().value(),
                   EkxProtocol::Payload::Nack::NackReason::PayloadBroken );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::processAlive( const bool bAlive )
{
    if ( !bAlive )
    {
        setValid( false );
        setRunning( false );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setValid( const bool bValid )
{
    if ( bValid != m_bValid )
    {
        m_bValid = bValid;
        emit validChanged( m_bValid );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setMotorTestOk( const bool bOk )
{
    if ( m_bMotorTestOk != bOk )
    {
        m_bMotorTestOk = bOk;
        emit motorTestChanged( m_bMotorTestOk );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setRunning( const bool bRunning )
{
    if ( m_bRunning != bRunning )
    {
        m_bRunning = bRunning;
        emit runningChanged( m_bRunning );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setFaultPinActive( const bool bActive )
{
    if ( m_bFaultPinActive != bActive )
    {
        m_bFaultPinActive = bActive;
        emit faultPinActiveChanged( m_bFaultPinActive );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setRunTimeMs( const int nRunTimeMs )
{
    if ( m_nRunTimeMs != nRunTimeMs )
    {
        m_nRunTimeMs = nRunTimeMs;
        emit runTimeMsChanged( m_nRunTimeMs );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setStepCounter( const quint32 u32StepCounter )
{
    if ( m_u32StepCounter != u32StepCounter )
    {
        m_u32StepCounter = u32StepCounter;
        emit stepCounterChanged( m_u32StepCounter );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspDcHallMotorDriver::setOvershootSteps( const quint32 u32OvershootSteps )
{
    if ( m_u32OvershootSteps != u32OvershootSteps )
    {
        m_u32OvershootSteps = u32OvershootSteps;
        emit overshootStepsChanged( m_u32OvershootSteps );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

