///////////////////////////////////////////////////////////////////////////////
///
/// @file EspMcuDriver.cpp
///
/// @brief main application entry point of EspMcuDriver.
///
/// @author Ultratronik GmbH
///         Dornierstr. 9
///         D-82205 Gilching
///         Germany
///         http://www.ultratronik.de
///
/// @author written by Florian Sonntag, Forschung & Entwicklung, gesser@ultratronik.de
///
/// @date 31.03.2021
///
/// @copyright Copyright 2021 by Hemro International AG
///            Hemro International AG
///            Länggenstrasse 34
///            CH 8184 Bachenbülach
///            Switzerland
///            Homepage: www.hemrogroup.com
///
///////////////////////////////////////////////////////////////////////////////

#include "EspSystemDriver.h"
#include "MainStatemachine.h"
#include "EspDriver.h"

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

EspSystemDriver::EspSystemDriver( const EkxProtocol::DriverId u8DriverId )
    : EspDeviceDriver( u8DriverId )
{

}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

EspSystemDriver::~EspSystemDriver()
{

}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::create(MainStatemachine * const pMainStatemachine)
{
    m_pMainStatemachine = pMainStatemachine;

    EspDeviceDriver::create( m_pMainStatemachine->espDriver()->protocolStack() );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspSystemDriver::u32MessageNumTx() const
{
    return m_u32MessageNumTx;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setMessageNumTx( const quint32 u32MessageNumTx)
{
    m_u32MessageNumTx = u32MessageNumTx;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspSystemDriver::u32MessageNumRx() const
{
    return m_u32MessageNumRx;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setMessageNumRx( const quint32 u32MessageNumRx )
{
    m_u32MessageNumRx = u32MessageNumRx;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspSystemDriver::u32MessageNumRxErrors() const
{
    return m_u32MessageNumRxErrors;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setMessageNumRxErrors( const quint32 u32MessageNumRxErrors )
{
    m_u32MessageNumRxErrors = u32MessageNumRxErrors;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspSystemDriver::u32MessageNumTxTimeouts() const
{
    return m_u32MessageNumTxTimeouts;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::processMessageFrame( const EkxProtocol::MessageFrame & frame )
{
    const EkxProtocol::Payload::SystemStatus * pPayload = dynamic_cast<const EkxProtocol::Payload::SystemStatus *>( frame.payloadRef().value() );

    if ( pPayload )
    {
        setStatus( pPayload->status().value() );
        setMessageNumTx( pPayload->messageNumTx().value() );
        setMessageNumRx( pPayload->messageNumRx().value() );
        setMessageNumTxTimeouts( pPayload->messageNumTxTimeouts().value() );
        setMessageNumRxErrors( pPayload->messageNumRxErrors().value() );
        setFreeHeapSize( pPayload->freeHeapSize().value() );

        replyAck( frame.driverId().value(),
                  frame.msgCounter().value(),
                  frame.repeatCounter().value() );
    }
    else
    {
        replyNack( frame.driverId().value(),
                   frame.msgCounter().value(),
                   frame.repeatCounter().value(),
                   EkxProtocol::Payload::Nack::NackReason::PayloadBroken );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setMessageNumTxTimeouts(quint32 u32MessageNumTxTimeouts)
{
    m_u32MessageNumTxTimeouts = u32MessageNumTxTimeouts;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

quint32 EspSystemDriver::freeHeapSize() const
{
    return m_u32FreeHeapSize;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setFreeHeapSize( const quint32 u32FreeHeapSize )
{
    m_u32FreeHeapSize = u32FreeHeapSize;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

EkxProtocol::Payload::SystemStatus::Status EspSystemDriver::status() const
{
    return m_u8Status;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void EspSystemDriver::setStatus( const EkxProtocol::Payload::SystemStatus::Status u8Status )
{
    m_u8Status = u8Status;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
