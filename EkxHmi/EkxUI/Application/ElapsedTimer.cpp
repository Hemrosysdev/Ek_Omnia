///////////////////////////////////////////////////////////////////////////////
///
/// @file ElapsedTimer.cpp
///
/// @brief Implementation file of class ElapsedTimer.
///
/// @author Ultratronik GmbH
///         Dornierstr. 9
///         D-82205 Gilching
///         Germany
///         http://www.ultratronik.de
///
/// @author written by Kai Uwe Broulik, kai.uwe.broulik@basyskom.com
///
/// @date 2023-02-24
///
/// @copyright Copyright 2021 by Hemro International AG
///            Hemro International AG
///            Länggenstrasse 34
///            CH 8184 Bachenbülach
///            Switzerland
///            Homepage: www.hemrogroup.com
///
///////////////////////////////////////////////////////////////////////////////

#include "ElapsedTimer.h"

#include <QTimer>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

ElapsedTimer::ElapsedTimer( QObject * parent )
    : QObject( parent )
    , m_pReportTimer( new QTimer( this ) )
{
    m_pReportTimer->setTimerType( Qt::PreciseTimer );
    connect( m_pReportTimer, &QTimer::timeout, this, &ElapsedTimer::report );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

ElapsedTimer::~ElapsedTimer() = default;

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int ElapsedTimer::elapsed() const
{
    return m_nElapsed;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

int ElapsedTimer::reportInterval() const
{
    return m_nReportInterval;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::setReportInterval( int nReportInterval )
{
    if ( m_nReportInterval != nReportInterval )
    {
        m_nReportInterval = nReportInterval;

        m_pReportTimer->setInterval( nReportInterval );

        Q_EMIT reportIntervalChanged( nReportInterval );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

bool ElapsedTimer::running() const
{
    return m_elapsedTimer.isValid();
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::setRunning( bool bRunning )
{
    if ( bRunning )
    {
        start();
    }
    else
    {
        stop();
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::start()
{
    if ( !running() )
    {
        restart();
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::restart()
{
    const bool bWasRunning = running();

    m_pReportTimer->start(); // restarts
    m_elapsedTimer.start();

    if ( bWasRunning != running() )
    {
        Q_EMIT runningChanged( running() );
    }

    report();
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::stop()
{
    if ( running() )
    {
        m_pReportTimer->stop();
        m_elapsedTimer.invalidate();
        report();

        Q_EMIT runningChanged( running() );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

void ElapsedTimer::report()
{
    int nElapsed = 0;
    if ( m_elapsedTimer.isValid() )
    {
        nElapsed = m_elapsedTimer.elapsed();
    }

    if ( m_nElapsed != nElapsed )
    {
        m_nElapsed = nElapsed;
        Q_EMIT elapsedChanged( nElapsed );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
